# "Distro" encapsulates the work needed to create UDP and TCP servers and clients and add a simple message protocol.

[![Build Status](https://travis-ci.org/hgarcia/distro.png?branch=master)](https://travis-ci.org/hgarcia/distro)

### UPDATES

0.3.1 Added documentation for 0.3.0
0.3.0 Added support for Redis and major changes on the API.
0.0.5 Added support for TCP servers and clients
0.0.2 Initial release

The API of version 0.3.1 has significant changes when compared to the previous versions, please read below.

### What's distro?

The distro module is intended to simplify the way services communicate with each other. It abstracts several different transports while providing a consistent interface. It also specifies a message format and comes with some helper factories to create and parse those messages.

It comes with some pre-packaged trasports for udp4 and udp6, tcp and redis (using pub-sub).
You can easily create your own transports as plug-ins (more details below).

### Usage cases.

Let's say you have an orders service that creates orders for customers. You also want to keep the rolling total for a given customer and you want the customer service to update the data on the customer.

Distro can easily dispatch a message to the proper service. On the orders service you will have some code like this:

    var updateCustomer = distro.createMessage({uri: "/customer/", address: "customer.service.com", port: 442200}; {})
    distro.create('tcp').client({port: 41234, address: 'customer.service.com'}).send(updateCustomer);

### Install

Simple do `npm install distro`


### Creating a server

Creating a server is as simple as:

    var distro = require("distro");

    var server = distro.create()
      .udp4Server({port: 41234})
      .receive(cb);

    function cb(err, msg) {
      console.log("Handling message: " + msg.id);
    }

You can register multiple handlers per server, just call receive again.

    var distro = require("../src/client_server");

    var server = distro.create()
      .udp4Server({port: 41234});

    server.receive(handler1);
    server.receive(handler2)

### A server is nothing without a client

    var distro = require("distro");
    var client = distro.create()
      .udp4Client({port: 41234})
      .send(obj);

The send method takes a distro `Message` that you can easily create using the library.

### The Messages

Messages need at least two parameteres, a headers object and a payload.
The headers needs at least one property (uri).

    var distro = require("distro");
    var header = {uri: "/object/main" };
    var msg = distro.create().message(headers, payload);

If you want to receive confirmation once the message is received you can add the server information to the headers object.

    var distro = require("distro");
    var header = {
      uri: "/object/main",
      address: "localhost",
      port: 42234
    };
    var msg = distro.create().message(headers, payload);

The server(s) that receives a message with origin information will send back a RECEIVED message to such origin.
The payload of a RECEIVED message is the id of the message.

Messages Id are autogenerated UUID, the payload of a message can be any serializable object. This is a very important consideration since recursive objects will not work properly.

### Working with "verbs"

This is not supported by users datagrams but have been added to standardize interfaces with a future project that I have in mind.

The headers object can have a `verb` property that maps to some of the http verbs. At the moment the supported verbs are `HEAD, GET, POST, PUT, DELETE` and `PATCH`.

What do I mean with supported verbs, you may ask?

The server object can register different handlers for each of those verbs. Instead of registering handlers with the `receive` method you can use specific verbs methods.

    var distro = require("distro");

    var server = distro.create()
      .udp4Server({port: 41234})

    server.head(handleHeadVerb);
    server.get(handleGetVerb);
    server.post(handlePostVerb);
    server.put(handlePutVerb);
    server.del(handleDeleteVerb);
    server.patch(handlePathVerb);

You don't need to specify the `get` verb for messages. If you registered handlers with the `get` method and your messages don't have a verb, this handler(s) will be used.

You can still add handlers to `receive` that will be called no matter the verb of the messages, this can be helpful for audit, logging or error handlers purposes.

## API Documentation

#### parse(data)

Given a serialized `Message` returns a `Message` object

#### create([logger])

The `logger` is any object that implements the `log` method. If a logger is not given the native `console` object will be used.

Returns a `distro` object

#### distro.message(headers, payload)

Creates a new `Message` object with the given headers and payload.

#### distro.tcpServer()
#### distro.udp4Server()
#### distro.udp6Server()

Returns a `Server` object that uses the protocol in the function name prefix.

#### distro.tcpClient()
#### distro.udp4Client()
#### distro.udp6Client()

Returns a `Client` object that uses the protocol in the function name prefix.

#### server.receive([callback])

Adds a listener that will be called each time the server is called, without consideration of the verb used in the `headers`

#### server.head([callback])
#### server.get([callback])
#### server.post([callback])
#### server.put([callback])
#### server.del([callback])
#### server.patch([callback])

Adds the listener to be called when a message is received for the given verb on the `headers`

#### new Message(id, headers, payload)

The `id` is expected to be a UUID.
The `verb` for the message. Defaults to `GET`
The `headers` object contains a `uri`, an `address` for the server/client to talk to and a `port` number.
The `payload` should be a 'flat' serializable object.

#### message.toString()

Returns a string representation of a serialized `Message`

#### message.toBuffer()

Return a buffer with the result of calling `toString()` on the `Message`